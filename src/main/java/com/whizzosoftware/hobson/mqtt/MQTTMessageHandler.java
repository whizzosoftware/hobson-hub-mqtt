/*
 *******************************************************************************
 * Copyright (c) 2015 Whizzo Software, LLC.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************
*/
package com.whizzosoftware.hobson.mqtt;

import com.whizzosoftware.hobson.api.plugin.PluginContext;
import com.whizzosoftware.hobson.api.variable.DeviceVariableContext;
import com.whizzosoftware.hobson.api.variable.DeviceVariableState;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.regex.Pattern;

/**
 * Class responsible for processing incoming MQTT messages. Examples are device registration and device data
 * submission messages.
 *
 * @author Dan Noguerol
 */
public class MQTTMessageHandler {
    private static final Logger logger = LoggerFactory.getLogger(MQTTMessageHandler.class);

    private PluginContext ctx;
    private MQTTMessageSink sink;
    private MQTTEventDelegate delegate;
    private Pattern deviceDataTopicPattern = Pattern.compile("^device/.*/data$");

    /**
     * Constructor.
     *
     * @param sink the transport to use for sending response messages
     * @param delegate the listener to notify of events generated by incoming messages
     */
    public MQTTMessageHandler(PluginContext ctx, MQTTMessageSink sink, MQTTEventDelegate delegate) {
        this.ctx = ctx;
        this.sink = sink;
        this.delegate = delegate;
    }

    /**
     * Called when an MQTT message is received.
     *
     * @param topic the topic the message was received on
     * @param json the JSON payload of the message
     */
    public void onMessage(String topic, JSONObject json) {
        logger.trace("Received MQTT message on topic {}: {}", topic, json);

        if ("bootstrap".equals(topic)) {
            if (json.has("deviceId") && json.has("nonce")) {
                String deviceId = json.getString("deviceId");
                String nonce = json.getString("nonce");

                JSONObject res = new JSONObject();

                if (delegate.hasDevice(deviceId)) {
                    if (!delegate.isDeviceActivated(deviceId)) {
                        // activate device
                        Map<String,Object> vars = null;
                        if (json.has("data")) {
                            vars = new HashMap<>();
                            JSONObject data = json.getJSONObject("data");
                            for (Object o : data.keySet()) {
                                String key = o.toString();
                                vars.put(key, data.get(key));
                            }
                        }
                        delegate.activateDevice(deviceId, vars);

                        // create JSON response message
                        res.put("id", deviceId);
                        res.put("secret", delegate.getDeviceSecret(deviceId));
                        res.put("topics", createTopicJson(deviceId));
                    } else {
                        res.put("topics", createTopicJson(deviceId));
                    }
                } else {
                    res.put("error", "Unable to bootstrap device");
                }

                // send response message
                String responseTopic = "bootstrap/" + deviceId + "/" + nonce;
                logger.debug("Registration message detected from {}; sending response on topic {}", deviceId, responseTopic);
                sink.sendMessage(responseTopic, res);
            } else {
                logger.error("Device registration missing device ID or nonce");
            }
        } else if (deviceDataTopicPattern.matcher(topic).matches()) {
            try {
                // alert listener of received data
                int ix = topic.indexOf('/') + 1;
                String deviceId = topic.substring(ix, topic.indexOf('/', ix));
                if (delegate.hasDevice(deviceId)) {
                    delegate.onDeviceData(deviceId, createVariableUpdates(deviceId, json));
                } else {
                    logger.error("Received data from device with invalid bootstrap identifier");
                }
            } catch (JSONException e) {
                logger.error("Error parsing device data JSON", e);
            }
        }
    }

    protected Collection<DeviceVariableState> createVariableUpdates(String deviceId, JSONObject json) {
        long now = System.currentTimeMillis();
        List<DeviceVariableState> updates = new ArrayList<>();
        for (Object o : json.keySet()) {
            String key = o.toString();
            updates.add(new DeviceVariableState(DeviceVariableContext.create(ctx, deviceId, key), json.get(key), now));
        }
        return updates;
    }

    private JSONObject createTopicJson(String id) {
        JSONObject topics = new JSONObject();
        topics.put("data", "device/" + id + "/data");
        topics.put("command", "device/" + id + "/command");
        return topics;
    }
}
